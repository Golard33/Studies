#pragma config(Sensor, S1,     tactileAvant,   sensorTouch)
#pragma config(Sensor, S2,     tactileArriere, sensorTouch)
#pragma config(Sensor, S3,     CaptLumi,       sensorLightActive)
#pragma config(Sensor, S4,     Ultrason,       sensorSONAR)
#pragma config(Motor,  motorA,          mPince,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mDroit,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mGauche,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define diamRoue 56
#define entraxe 114
#define distance 500 // mm
#define avant 1
#define arriere -1
#define gauche 0
#define droite 1

void Tourner (int direction, int angleRot, int puissance)
{
	long p;
	p = (( (long)entraxe * angleRot) / diamRoue);
	if (direction== droite)
		{
			nMotorEncoder[mGauche] = 0;
			nMotorEncoder[mDroit] = 0;
			motor[mDroit] =30* (-1);
			motor[mGauche] = 30;
			while ( nMotorEncoder[mGauche]   <= p)
			{
			}
			motor[mGauche] = 0;
			nMotorEncoder[mGauche] = 0;
		}
		else
		{
			nMotorEncoder[mGauche] = 0;
			nMotorEncoder[mDroit] = 0;

			motor[mDroit] = 30 ;
			motor[mGauche] = 30* (-1);
			while ( nMotorEncoder[mDroit]  <=p)
			{
			}
			motor[mDroit] = 0;
			nMotorEncoder[mDroit] = 0;
		}

}

void avancerDistance (int D, int puissance)
{
	long conversion;
	conversion = ((long)D * 360) /( PI * diamRoue);

			nMotorEncoder[mDroit] = 0;
			motor[mDroit] =30;
			motor[mGauche] = 30;
			while ( nMotorEncoder[mDroit] <= conversion)
			{
			}
			motor[mGauche] = 0;
			motor[mDroit] = 0;

}


task main()
{
	int i = 1 ;
	while ( i<=4){
	avancerDistance(distance, 30);
		Tourner(droite, 87, 30);
			i = i+1;
	}

}
